{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Catalyst is a powerful Discord bot. It's built in a very modular structure made maintenability and extendability. It can also be used as a framework to create a bot. Getting Started Catalyst can be used through slash commands or through chat commands. Chat commands must start with a prefix, which tells the bot that the user is sending a command. The default prefix is c! , meaning you could run the help command by doing c!help . Additionally, you can provide arguments to the command. In case of the help command, you can type c!help kick to view information about the kick command. The format for providing arguments to commands is as follows: c!command argument1 argument2 ... . Multiple commands can be executed, by using the statement terminator. The default statement terminator is ; . The format for running statements is as follows: c!statement1; statement2; ... . Here's an example of using all three syntax guidelines, that says hi and runs the ping command: c!echo hi; ping Slash Commands Like most modern Discord bots, Catalyst has full support for slash commands. Slash commands can be accessed by typing the forward-slash key in the message box. This will open a menu of commands that can be run, by the different bots accessable in the channel.","title":"Getting Started"},{"location":"#getting-started","text":"Catalyst can be used through slash commands or through chat commands. Chat commands must start with a prefix, which tells the bot that the user is sending a command. The default prefix is c! , meaning you could run the help command by doing c!help . Additionally, you can provide arguments to the command. In case of the help command, you can type c!help kick to view information about the kick command. The format for providing arguments to commands is as follows: c!command argument1 argument2 ... . Multiple commands can be executed, by using the statement terminator. The default statement terminator is ; . The format for running statements is as follows: c!statement1; statement2; ... . Here's an example of using all three syntax guidelines, that says hi and runs the ping command: c!echo hi; ping","title":"Getting Started"},{"location":"#slash-commands","text":"Like most modern Discord bots, Catalyst has full support for slash commands. Slash commands can be accessed by typing the forward-slash key in the message box. This will open a menu of commands that can be run, by the different bots accessable in the channel.","title":"Slash Commands"},{"location":"arguments/","text":"Arguments Arguments allow you to pass information to commands. There are different types of arguments, such as text, integers, channels, and users. Sometimes an argument is is required to run a command, but they can also be optional. Arguments can have choices too, where you have to choose from a list of options. Prompting If a command request is sent but all required arguments are not provided, then Catalyst will ask you to provide it with the arguments in a prompt. This is done to create a smoother, more human-like experience. An example of this is in the echo command, which replies with the text you send. If no arguments are provided, there is nothing to say and the bot will ask you to tell it something to say. This is easier than just being told to run the command all over again, but with a message. Types There are many different types of arguments. These are done to make the job of the individual command easier. The argument types are as follow: text: This can be any text. integer: These can only be integers, meaning they cannot have decimals. When used in the chat, they can also be in hexadecimal or exponential form. number: These can be any number at all. When used in the chat, they can also be in hexadecimal or exponential form. time: This is used to represent a time interval. An example of this is 5h30m , which is 5 hours and 30 minutes. Time intervals are as follows: s for seconds, m for minutes, h for hours, d for days, w for weeks, y for years. boolean: This is use to represent an on-off value. On is yes , on , or true . Off is no , off , or false . user: These are mentioned users. member: These are users that are in the guild. channel: These are channels in the guild. role: These are roles in the guild. mentionable: These are anything mentionable, which includes @everyone and @here (they aren't technically roles, but they are mentionable).","title":"Arguments"},{"location":"arguments/#arguments","text":"Arguments allow you to pass information to commands. There are different types of arguments, such as text, integers, channels, and users. Sometimes an argument is is required to run a command, but they can also be optional. Arguments can have choices too, where you have to choose from a list of options.","title":"Arguments"},{"location":"arguments/#prompting","text":"If a command request is sent but all required arguments are not provided, then Catalyst will ask you to provide it with the arguments in a prompt. This is done to create a smoother, more human-like experience. An example of this is in the echo command, which replies with the text you send. If no arguments are provided, there is nothing to say and the bot will ask you to tell it something to say. This is easier than just being told to run the command all over again, but with a message.","title":"Prompting"},{"location":"arguments/#types","text":"There are many different types of arguments. These are done to make the job of the individual command easier. The argument types are as follow: text: This can be any text. integer: These can only be integers, meaning they cannot have decimals. When used in the chat, they can also be in hexadecimal or exponential form. number: These can be any number at all. When used in the chat, they can also be in hexadecimal or exponential form. time: This is used to represent a time interval. An example of this is 5h30m , which is 5 hours and 30 minutes. Time intervals are as follows: s for seconds, m for minutes, h for hours, d for days, w for weeks, y for years. boolean: This is use to represent an on-off value. On is yes , on , or true . Off is no , off , or false . user: These are mentioned users. member: These are users that are in the guild. channel: These are channels in the guild. role: These are roles in the guild. mentionable: These are anything mentionable, which includes @everyone and @here (they aren't technically roles, but they are mentionable).","title":"Types"},{"location":"guardian/","text":"Guardian Catalyist comes with an all-purpose automated moderation system called Guardian. Guardian can scan messages, as well as users to ensure all users a safe experience. It is currently in development, and it will be released soon.","title":"Guardian"},{"location":"guardian/#guardian","text":"Catalyist comes with an all-purpose automated moderation system called Guardian. Guardian can scan messages, as well as users to ensure all users a safe experience. It is currently in development, and it will be released soon.","title":"Guardian"},{"location":"hosting/","text":"Self Hosting Because Catalyst is open source, it can be self-hosted. This means that it will run on your server and you have full control over the bot. To load the bot, you must first clone the git repository. This can be done by downlading the zip file through the GitHub page, or by cloning the repository through git by doing git clone https://github.com/optimisticside/catalyst.git . Once the reposity is loaded (and unzipped if downloaded through the GitHub website), you will want to download all the npm packages. This can be done by doing npm install . Once all packages are installed, you will need to install Redis. Redis is the database that Catalyst uses to store data about servers and users. For more information about installing Redis, visit https://redis.io/topics/quickstart . Once Redis is installed, it is time to create the configuration file. Go to the src directory and clone the config.template.json file and call it config.json . This is where the bot's configuration will be stored. See the Configuration section below. Once configured, the last thing left to do is to run the bot. You will have to start your redis server first, though. To run the bot, you can type npm start . This should start the bot, and the console will start printing logs coming from the bot's code. Congratulations, you've self-hosted Catalyst! Configuration The configuration file tells Catalyst information about how to run the bot. This includes information such as how to access the database, and the bot's token. NAME is the name of the bot, and can change (if you wnat a different name). CLIENT_ID is the client-ID of the client that Catalyst will run on. It is used to generate invite links. You can find it in the OAuth2 page of the bot in the Discord developer portal. TOKEN is the token to log onto the client. You can find it in the Bot page of the bot in the Discord developer portal. If you cannot find it there, then you will have to create the bot (there should be instructions on that page). CREATOR_ID is the user-ID of the bot's creator. This gives the creator debugging-permissions, if enabled. PREFIX is the prefix that all messages contianing commands must start with. REDIS_HOST is the IP Address/hostname that the Redis server is on. REDIS_PORT is the port that the Redis server is on. KEY_DELIM is how information will be joined into keys. For example, if the key-delimiter is : and the bot is trying to access foo.bar , then it will check the foo:bar key of the database.","title":"Hosting"},{"location":"hosting/#self-hosting","text":"Because Catalyst is open source, it can be self-hosted. This means that it will run on your server and you have full control over the bot. To load the bot, you must first clone the git repository. This can be done by downlading the zip file through the GitHub page, or by cloning the repository through git by doing git clone https://github.com/optimisticside/catalyst.git . Once the reposity is loaded (and unzipped if downloaded through the GitHub website), you will want to download all the npm packages. This can be done by doing npm install . Once all packages are installed, you will need to install Redis. Redis is the database that Catalyst uses to store data about servers and users. For more information about installing Redis, visit https://redis.io/topics/quickstart . Once Redis is installed, it is time to create the configuration file. Go to the src directory and clone the config.template.json file and call it config.json . This is where the bot's configuration will be stored. See the Configuration section below. Once configured, the last thing left to do is to run the bot. You will have to start your redis server first, though. To run the bot, you can type npm start . This should start the bot, and the console will start printing logs coming from the bot's code. Congratulations, you've self-hosted Catalyst!","title":"Self Hosting"},{"location":"hosting/#configuration","text":"The configuration file tells Catalyst information about how to run the bot. This includes information such as how to access the database, and the bot's token. NAME is the name of the bot, and can change (if you wnat a different name). CLIENT_ID is the client-ID of the client that Catalyst will run on. It is used to generate invite links. You can find it in the OAuth2 page of the bot in the Discord developer portal. TOKEN is the token to log onto the client. You can find it in the Bot page of the bot in the Discord developer portal. If you cannot find it there, then you will have to create the bot (there should be instructions on that page). CREATOR_ID is the user-ID of the bot's creator. This gives the creator debugging-permissions, if enabled. PREFIX is the prefix that all messages contianing commands must start with. REDIS_HOST is the IP Address/hostname that the Redis server is on. REDIS_PORT is the port that the Redis server is on. KEY_DELIM is how information will be joined into keys. For example, if the key-delimiter is : and the bot is trying to access foo.bar , then it will check the foo:bar key of the database.","title":"Configuration"},{"location":"development/","text":"","title":"Getting Started"},{"location":"development/commands/","text":"","title":"Commands"},{"location":"development/echo/","text":"Case Study - Echo Command Lets take a look at the echo command. This is a great command to analyze because of how simple it is and how it utilizes OptionParsers to parse arguments. It also shows us how options can be used to provide a more fluid experience when developing commands. It's also a bit more interesting than the ping command, which we've all seen many times. const Command = require ( '../../structs/command.js' ); const OptionParser = require ( '../../util/optionParser.js' ); module . exports = class EchoCommand extends Command { async run ( client , given , args ) { const parser = new OptionParser ( this , given , args ); given . reply ( await parser . getOption ( 'message' )); } constructor () { super ({ name : 'echo' , desc : 'Repeats whatever you tell it.' , options : [ { name : 'message' , type : 'text' , desc : 'What you want me to say' , prompt : 'What do you want me to say?' , required : true } ] }) } }; This may look daunting at first, but let's break this down piece by piece. Improrts When you look at the top of the file, you will see come require calls. These import modules that will help us create our command. const Command = require ( '../../structs/command.js' ); const OptionParser = require ( '../../util/optionParser.js' ); The first line is importing the base class for commands. This allows you to easily declare command properties, and handles defaults. The second line is importing the OptionParser class. This allows you to parse commands, and provides an abstraction layer between chat and slash commands. Using this, however, is completely optional. This is why it is not done automatically by the system. Run function If you look inside the EchoCommand class, you will see an asynchronous function called run . This is the function that is called to execute the command. It is provided with a few arguments, which include the bot's client, the given information, and the arguments. async run ( client , given , args ) { const parser = new OptionParser ( this , given , args ); given . reply ( await parser . getOption ( 'message' )); } The first line of the function creates a new option parser, which will help us by parsing what we are given into types we can understand. The next line of the function calls the getOption function, which retrieves what the user has provided for one of our options (we'll talk about options later on). Awaiting for the function will give us a string. We will reply to what we are given with what is provided for the message argument.","title":"Case Study"},{"location":"development/echo/#case-study-echo-command","text":"Lets take a look at the echo command. This is a great command to analyze because of how simple it is and how it utilizes OptionParsers to parse arguments. It also shows us how options can be used to provide a more fluid experience when developing commands. It's also a bit more interesting than the ping command, which we've all seen many times. const Command = require ( '../../structs/command.js' ); const OptionParser = require ( '../../util/optionParser.js' ); module . exports = class EchoCommand extends Command { async run ( client , given , args ) { const parser = new OptionParser ( this , given , args ); given . reply ( await parser . getOption ( 'message' )); } constructor () { super ({ name : 'echo' , desc : 'Repeats whatever you tell it.' , options : [ { name : 'message' , type : 'text' , desc : 'What you want me to say' , prompt : 'What do you want me to say?' , required : true } ] }) } }; This may look daunting at first, but let's break this down piece by piece.","title":"Case Study - Echo Command"},{"location":"development/echo/#improrts","text":"When you look at the top of the file, you will see come require calls. These import modules that will help us create our command. const Command = require ( '../../structs/command.js' ); const OptionParser = require ( '../../util/optionParser.js' ); The first line is importing the base class for commands. This allows you to easily declare command properties, and handles defaults. The second line is importing the OptionParser class. This allows you to parse commands, and provides an abstraction layer between chat and slash commands. Using this, however, is completely optional. This is why it is not done automatically by the system.","title":"Improrts"},{"location":"development/echo/#run-function","text":"If you look inside the EchoCommand class, you will see an asynchronous function called run . This is the function that is called to execute the command. It is provided with a few arguments, which include the bot's client, the given information, and the arguments. async run ( client , given , args ) { const parser = new OptionParser ( this , given , args ); given . reply ( await parser . getOption ( 'message' )); } The first line of the function creates a new option parser, which will help us by parsing what we are given into types we can understand. The next line of the function calls the getOption function, which retrieves what the user has provided for one of our options (we'll talk about options later on). Awaiting for the function will give us a string. We will reply to what we are given with what is provided for the message argument.","title":"Run function"},{"location":"development/groups/","text":"","title":"Groups"},{"location":"development/options/","text":"","title":"Options"}]}