{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Catalyst is a powerful Discord bot. It's built in a very modular structure made maintenability and extendability. It can also be used as a framework to create a bot. Getting Started Catalyst can be used through slash commands or through chat commands. Chat commands must start with a prefix, which tells the bot that the user is sending a command. The default prefix is c! , meaning you could run the help command by doing c!help . Additionally, you can provide arguments to the command. In case of the help command, you can type c!help kick to view information about the kick command. The format for providing arguments to commands is as follows: c!command argument1 argument2 ... . Multiple commands can be executed, by using the statement terminator. The default statement terminator is ; . The format for running statements is as follows: c!statement1; statement2; ... . Here's an example of using all three syntax guidelines, that says hi and runs the ping command: c!echo hi; ping Slash Commands Like most modern Discord bots, Catalyst has full support for slash commands. Slash commands can be accessed by typing the forward-slash key in the message box. This will open a menu of commands that can be run, by the different bots accessable in the channel.","title":"Home"},{"location":"#getting-started","text":"Catalyst can be used through slash commands or through chat commands. Chat commands must start with a prefix, which tells the bot that the user is sending a command. The default prefix is c! , meaning you could run the help command by doing c!help . Additionally, you can provide arguments to the command. In case of the help command, you can type c!help kick to view information about the kick command. The format for providing arguments to commands is as follows: c!command argument1 argument2 ... . Multiple commands can be executed, by using the statement terminator. The default statement terminator is ; . The format for running statements is as follows: c!statement1; statement2; ... . Here's an example of using all three syntax guidelines, that says hi and runs the ping command: c!echo hi; ping","title":"Getting Started"},{"location":"#slash-commands","text":"Like most modern Discord bots, Catalyst has full support for slash commands. Slash commands can be accessed by typing the forward-slash key in the message box. This will open a menu of commands that can be run, by the different bots accessable in the channel.","title":"Slash Commands"},{"location":"arguments/","text":"Arguments Arguments allow you to pass information to commands. There are different types of arguments, such as text, integers, channels, and users. Sometimes an argument is is required to run a command, but they can also be optional. Arguments can have choices too, where you have to choose from a list of options. Prompting If a command request is sent but all required arguments are not provided, then Catalyst will ask you to provide it with the arguments in a prompt. This is done to create a smoother, more human-like experience. An example of this is in the echo command, which replies with the text you send. If no arguments are provided, there is nothing to say and the bot will ask you to tell it something to say. This is easier than just being told to run the command all over again, but with a message. Types There are many different types of arguments. These are done to make the job of the individual command easier. The argument types are as follow: text: This can be any text. integer: These can only be integers, meaning they cannot have decimals. When used in the chat, they can also be in hexadecimal or exponential form. number: These can be any number at all. When used in the chat, they can also be in hexadecimal or exponential form. time: This is used to represent a time interval. An example of this is 5h30m , which is 5 hours and 30 minutes. Time intervals are as follows: s for seconds, m for minutes, h for hours, d for days, w for weeks, y for years. boolean: This is use to represent an on-off value. On is yes , on , or true . Off is no , off , or false . user: These are mentioned users. member: These are users that are in the guild. channel: These are channels in the guild. role: These are roles in the guild. mentionable: These are anything mentionable, which includes @everyone and @here (they aren't technically roles, but they are mentionable).","title":"Arguments"},{"location":"arguments/#arguments","text":"Arguments allow you to pass information to commands. There are different types of arguments, such as text, integers, channels, and users. Sometimes an argument is is required to run a command, but they can also be optional. Arguments can have choices too, where you have to choose from a list of options.","title":"Arguments"},{"location":"arguments/#prompting","text":"If a command request is sent but all required arguments are not provided, then Catalyst will ask you to provide it with the arguments in a prompt. This is done to create a smoother, more human-like experience. An example of this is in the echo command, which replies with the text you send. If no arguments are provided, there is nothing to say and the bot will ask you to tell it something to say. This is easier than just being told to run the command all over again, but with a message.","title":"Prompting"},{"location":"arguments/#types","text":"There are many different types of arguments. These are done to make the job of the individual command easier. The argument types are as follow: text: This can be any text. integer: These can only be integers, meaning they cannot have decimals. When used in the chat, they can also be in hexadecimal or exponential form. number: These can be any number at all. When used in the chat, they can also be in hexadecimal or exponential form. time: This is used to represent a time interval. An example of this is 5h30m , which is 5 hours and 30 minutes. Time intervals are as follows: s for seconds, m for minutes, h for hours, d for days, w for weeks, y for years. boolean: This is use to represent an on-off value. On is yes , on , or true . Off is no , off , or false . user: These are mentioned users. member: These are users that are in the guild. channel: These are channels in the guild. role: These are roles in the guild. mentionable: These are anything mentionable, which includes @everyone and @here (they aren't technically roles, but they are mentionable).","title":"Types"},{"location":"guardian/","text":"","title":"Guardian"},{"location":"hosting/","text":"","title":"Hosting"},{"location":"development/commands/","text":"","title":"Commands"},{"location":"development/echo/","text":"Case Study - Echo Command Lets take a look at the echo command. This is a great command to analyze because of how simple it is and how it utilizes OptionParsers to parse arguments. It also shows us how options can be used to provide a more fluid experience when developing commands. It's also a bit more interesting than the ping command, which we've all seen many times. const Command = require('../../structs/command.js'); const OptionParser = require('../../util/optionParser.js'); module.exports = class EchoCommand extends Command { async run(client, given, args) { const parser = new OptionParser(this, given, args); given.reply(await parser.getOption('message')); } constructor() { super({ name: 'echo', desc: 'Repeats whatever you tell it.', options: [ { name: 'message', type: 'text', desc: 'What you want me to say', prompt: 'What do you want me to say?', required: true } ] }) } }; This may look daunting at first, but let's break this down piece by piece. Improrts When you look at the top of the file, you will see come require calls. These import modules that will help us create our command. const Command = require('../../structs/command.js'); const OptionParser = require('../../util/optionParser.js'); The first line is importing the base class for commands. This allows you to easily declare command properties, and handles defaults. The second line is importing the OptionParser class. This allows you to parse commands, and provides an abstraction layer between chat and slash commands. Using this, however, is completely optional. This is why it is not done automatically by the system. Run function If you look inside the EchoCommand class, you will see an asynchronous function called run . This is the function that is called to execute the command. It is provided with a few arguments, which include the bot's client, the given information, and the arguments. async run(client, given, args) { const parser = new OptionParser(this, given, args); given.reply(await parser.getOption('message')); } The first line of the function creates a new option parser, which will help us by parsing what we are given into types we can understand. The next line of the function calls the getOption function, which retrieves what the user has provided for one of our options (we'll talk about options later on). Awaiting for the function will give us a string. We will reply to what we are given with what is provided for the message argument.","title":"Case Study - Echo Command"},{"location":"development/echo/#case-study-echo-command","text":"Lets take a look at the echo command. This is a great command to analyze because of how simple it is and how it utilizes OptionParsers to parse arguments. It also shows us how options can be used to provide a more fluid experience when developing commands. It's also a bit more interesting than the ping command, which we've all seen many times. const Command = require('../../structs/command.js'); const OptionParser = require('../../util/optionParser.js'); module.exports = class EchoCommand extends Command { async run(client, given, args) { const parser = new OptionParser(this, given, args); given.reply(await parser.getOption('message')); } constructor() { super({ name: 'echo', desc: 'Repeats whatever you tell it.', options: [ { name: 'message', type: 'text', desc: 'What you want me to say', prompt: 'What do you want me to say?', required: true } ] }) } }; This may look daunting at first, but let's break this down piece by piece.","title":"Case Study - Echo Command"},{"location":"development/echo/#improrts","text":"When you look at the top of the file, you will see come require calls. These import modules that will help us create our command. const Command = require('../../structs/command.js'); const OptionParser = require('../../util/optionParser.js'); The first line is importing the base class for commands. This allows you to easily declare command properties, and handles defaults. The second line is importing the OptionParser class. This allows you to parse commands, and provides an abstraction layer between chat and slash commands. Using this, however, is completely optional. This is why it is not done automatically by the system.","title":"Improrts"},{"location":"development/echo/#run-function","text":"If you look inside the EchoCommand class, you will see an asynchronous function called run . This is the function that is called to execute the command. It is provided with a few arguments, which include the bot's client, the given information, and the arguments. async run(client, given, args) { const parser = new OptionParser(this, given, args); given.reply(await parser.getOption('message')); } The first line of the function creates a new option parser, which will help us by parsing what we are given into types we can understand. The next line of the function calls the getOption function, which retrieves what the user has provided for one of our options (we'll talk about options later on). Awaiting for the function will give us a string. We will reply to what we are given with what is provided for the message argument.","title":"Run function"},{"location":"development/groups/","text":"","title":"Groups"}]}